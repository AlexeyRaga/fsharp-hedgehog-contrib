{
  "api/Hedgehog.Stateful.ActionCommand_TSystem, TState, TInput_.html": {
    "href": "api/Hedgehog.Stateful.ActionCommand_TSystem, TState, TInput_.html",
    "title": "Class ActionCommand<'TSystem, 'TState, 'TInput> | Hedgehog.Stateful",
    "summary": "Class ActionCommand<'TSystem, 'TState, 'TInput> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Base class for commands that perform side-effects without returning meaningful values. Examples: closing a connection, clearing a cache, deleting a file. Simpler than Command because no output variable is needed. Execute returns a Task to support both synchronous and asynchronous operations. The SUT is passed as a typed parameter to Execute and Ensure. F# C# type ActionCommand<'TSystem, 'TState, 'TInput> = abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput -> bool abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task abstract member Generate : 'TState -> Gen<'TInput> abstract member Name : string abstract member Precondition : 'TState -> bool abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract member Update : state:'TState * input:'TInput -> 'TState public class ActionCommand<TSystem, TState, TInput> { abstract bool Ensure(Env env, TState oldState, TState newState, TInput input) abstract Task Execute(TSystem sut, Env env, TState state, TInput input) abstract Gen<TInput> Generate(TState state) abstract string Name() abstract bool Precondition(TState state) abstract bool Require(Env env, TState state, TInput input) abstract TState Update(TState state, TInput input) } Methods Ensure Verify the action's postcondition after execution. Compare the model state transitions (s0 -> s1) with the input. Should only verify based on states and input - not inspect the SUT directly. No output parameter since actions don't produce values. Returns true if postcondition is satisfied, false otherwise. May throw exceptions which will be caught and treated as failures. Parameters: env: The environment containing resolved values from previous commands. oldState: The model state before the action executed. newState: The model state after the action executed. input: The input value for this action. F# C# abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput -> bool abstract bool Ensure(Env env, TState oldState, TState newState, TInput input) Execute Execute the action against the real system without returning a value. For synchronous operations, use Task.CompletedTask. The sut parameter is the typed System Under Test. The state parameter is the current model state. The env contains resolved values from previous commands. Parameters: sut: The system under test. env: The environment containing resolved values from previous commands. state: The current model state. input: The input value for this action. F# C# abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task abstract Task Execute(TSystem sut, Env env, TState state, TInput input) Generate Generate random input for this action given the current model state. This is only called when Precondition returns true. Parameters: state: The current model state. F# C# abstract member Generate : 'TState -> Gen<'TInput> abstract Gen<TInput> Generate(TState state) Precondition Structural precondition that determines if this action can be generated/executed in the given state. Return true if the action can run, false to skip generation. This is automatically used by both generation and Require (unless Require is overridden). Parameters: state: The current model state. F# C# abstract member Precondition : 'TState -> bool abstract bool Precondition(TState state) Require Check if the action can be executed in the given state with concrete values. Return false if the action should not be executed in this state. The env parameter allows resolving symbolic variables from the state. By default, returns true. Override only when you need to check concrete values with env. Note: Precondition is always checked separately, so you don't need to duplicate those checks here. Parameters: env: The environment containing resolved values from previous commands. state: The current model state. input: The concrete input value for this action. F# C# abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract bool Require(Env env, TState state, TInput input) Update Update the model state after the action executes. No output variable since actions don't produce values to reference later. Parameters: state: The current model state. input: The input value for this action. F# C# abstract member Update : state:'TState * input:'TInput -> 'TState abstract TState Update(TState state, TInput input) Name Human-readable name of the action (e.g., \"Close\", \"Clear\", \"Delete\") F# C# abstract member Name : string abstract string Name()"
  },
  "api/Hedgehog.Stateful.ActionGen_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.ActionGen_TSystem, TState_.html",
    "title": "Class ActionGen<'TSystem, 'TState> | Hedgehog.Stateful",
    "summary": "Class ActionGen<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Existential wrapper to allow heterogeneous command lists. This erases the input/output types so different commands can be in the same list. F# C# type ActionGen<'TSystem, 'TState> public class ActionGen<TSystem, TState>"
  },
  "api/Hedgehog.Stateful.Command_TSystem, TState, TInput, TOutput_.html": {
    "href": "api/Hedgehog.Stateful.Command_TSystem, TState, TInput, TOutput_.html",
    "title": "Class Command<'TSystem, 'TState, 'TInput, 'TOutput> | Hedgehog.Stateful",
    "summary": "Class Command<'TSystem, 'TState, 'TInput, 'TOutput> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Base class for commands that perform stateful operations and return values. Commands are the building blocks of state machine tests - they represent operations on a system under test (SUT) that can be generated, executed, and verified. The SUT is passed as a typed parameter to Execute and Ensure. Execute returns a Task to support both synchronous and asynchronous operations. F# C# type Command<'TSystem, 'TState, 'TInput, 'TOutput> = abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput * output:'TOutput -> bool abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task<'TOutput> abstract member Generate : 'TState -> Gen<'TInput> abstract member Name : string abstract member Precondition : 'TState -> bool abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract member Update : state:'TState * input:'TInput * output:Var<'TOutput> -> 'TState public class Command<TSystem, TState, TInput, TOutput> { abstract bool Ensure(Env env, TState oldState, TState newState, TInput input, TOutput output) abstract Task<TOutput> Execute(TSystem sut, Env env, TState state, TInput input) abstract Gen<TInput> Generate(TState state) abstract string Name() abstract bool Precondition(TState state) abstract bool Require(Env env, TState state, TInput input) abstract TState Update(TState state, TInput input, Var<TOutput> output) } Methods Ensure Verify the command's postcondition after execution. Compare the model state transitions (s0 -> s1) with the actual output. Should only verify based on states, input, and output - not inspect the SUT directly. Returns true if postcondition is satisfied, false otherwise. May throw exceptions which will be caught and treated as failures. Parameters: env: The environment containing resolved values from previous commands. oldState: The model state before the command executed. newState: The model state after the command executed. input: The input value for this command. output: The actual output value produced by the command. F# C# abstract member Ensure : env:Env * oldState:'TState * newState:'TState * input:'TInput * output:'TOutput -> bool abstract bool Ensure(Env env, TState oldState, TState newState, TInput input, TOutput output) Execute Execute the command against the real system, returning a Task. For synchronous operations, use Task.FromResult(value). The sut parameter is the typed System Under Test. The state parameter is the current model state. The env contains resolved values from previous commands. Parameters: sut: The system under test. env: The environment containing resolved values from previous commands. state: The current model state. input: The input value for this command. F# C# abstract member Execute : sut:'TSystem * env:Env * state:'TState * input:'TInput -> Task<'TOutput> abstract Task<TOutput> Execute(TSystem sut, Env env, TState state, TInput input) Generate Generate random input for this command given the current model state. This is only called when Precondition returns true. Parameters: state: The current model state. F# C# abstract member Generate : 'TState -> Gen<'TInput> abstract Gen<TInput> Generate(TState state) Precondition Structural precondition that determines if this command can be generated/executed in the given state. Return true if the command can run, false to skip generation. This is automatically used by both generation and Require (unless Require is overridden). Parameters: state: The current model state. F# C# abstract member Precondition : 'TState -> bool abstract bool Precondition(TState state) Require Check if the command can be executed in the given state with concrete values. Return false if the command should not be executed in this state. The env parameter allows resolving symbolic variables from the state. By default, returns true. Override only when you need to check concrete values with env. Note: Precondition is always checked separately, so you don't need to duplicate those checks here. Parameters: env: The environment containing resolved values from previous commands. state: The current model state. input: The concrete input value for this command. F# C# abstract member Require : env:Env * state:'TState * input:'TInput -> bool abstract bool Require(Env env, TState state, TInput input) Update Update the model state after the command executes. The Var represents the symbolic output that can be referenced by future commands. Parameters: state: The current model state. input: The input value for this command. output: The symbolic output variable that can be referenced by future commands. F# C# abstract member Update : state:'TState * input:'TInput * output:Var<'TOutput> -> 'TState abstract TState Update(TState state, TInput input, Var<TOutput> output) Name Human-readable name of the command (e.g., \"Push\", \"Pop\") F# C# abstract member Name : string abstract string Name()"
  },
  "api/Hedgehog.Stateful.Env.html": {
    "href": "api/Hedgehog.Stateful.Env.html",
    "title": "Class Env | Hedgehog.Stateful",
    "summary": "Class Env Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Environment mapping symbolic variable names to concrete values. The SUT is passed separately to Execute, not stored in Env. F# C# type Env public class Env"
  },
  "api/Hedgehog.Stateful.FSharp.Var.html": {
    "href": "api/Hedgehog.Stateful.FSharp.Var.html",
    "title": "Class Var | Hedgehog.Stateful",
    "summary": "Class Var Namespace Hedgehog.Stateful.FSharp Assembly Hedgehog.Stateful.dll F# C# type Var = member map : 'T -> 'U -> Var<'T> -> Var<'U> member resolve : Env -> Var<'T> -> 'T member resolveOr : 'T -> Env -> Var<'T> -> 'T member tryResolve : Var<'T> -> Env -> Result<'T, string> public class Var { public static Var<U> map(T -> U f, Var<T> v) public static T resolve(Env env, Var<T> v) public static T resolveOr(T fallback, Env env, Var<T> v) public static Result<T, string> tryResolve(Var<T> v, Env env) } Methods resolve Resolve a variable using its default value if not found in the environment. Parameters: env: The environment to resolve the variable from. v: The variable to resolve. F# C# member resolve : Env -> Var<'T> -> 'T public static T resolve(Env env, Var<T> v) resolveOr Resolve a variable with an explicit fallback value, overriding the variable's default. Parameters: fallback: The fallback value to use if the variable is not found. env: The environment to resolve the variable from. v: The variable to resolve. F# C# member resolveOr : 'T -> Env -> Var<'T> -> 'T public static T resolveOr(T fallback, Env env, Var<T> v) tryResolve Resolve a variable, returning Error if not found in the environment or if resolution fails. Parameters: v: The variable to resolve. env: The environment to resolve the variable from. F# C# member tryResolve : Var<'T> -> Env -> Result<'T, string> public static Result<T, string> tryResolve(Var<T> v, Env env) map Map a function over a variable, creating a new variable that projects a value from the original variable's output. This allows extracting fields from structured command outputs. Parameters: f: The projection function to apply. v: The variable to map over. F# C# member map : 'T -> 'U -> Var<'T> -> Var<'U> public static Var<U> map(T -> U f, Var<T> v)"
  },
  "api/Hedgehog.Stateful.ICommand_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.ICommand_TSystem, TState_.html",
    "title": "Class ICommand<'TSystem, 'TState> | Hedgehog.Stateful",
    "summary": "Class ICommand<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Interface for types that helps with converting commands to executable actions. This allows seamless mixing of different commands and action commands. F# C# type ICommand<'TSystem, 'TState> = abstract member ToActionGen : ActionGen<'TSystem, 'TState> public class ICommand<TSystem, TState> { abstract ActionGen<TSystem, TState> ToActionGen() } Methods ToActionGen F# C# abstract member ToActionGen : ActionGen<'TSystem, 'TState> abstract ActionGen<TSystem, TState> ToActionGen()"
  },
  "api/Hedgehog.Stateful.Linq.NoValue.html": {
    "href": "api/Hedgehog.Stateful.Linq.NoValue.html",
    "title": "Class NoValue | Hedgehog.Stateful",
    "summary": "Class NoValue Namespace Hedgehog.Stateful.Linq Assembly Hedgehog.Stateful.dll Represents the absence of value, that can be used for commands that don't require input parameters. Similar to F#'s unit type, this is a zero-sized struct with a single instance. F# C# type NoValue = member Value : NoValue public class NoValue { public static NoValue Value() } Methods Value F# C# member Value : NoValue public static NoValue Value()"
  },
  "api/Hedgehog.Stateful.Linq.SpecificationExtensions.html": {
    "href": "api/Hedgehog.Stateful.Linq.SpecificationExtensions.html",
    "title": "Class SpecificationExtensions | Hedgehog.Stateful",
    "summary": "Class SpecificationExtensions Namespace Hedgehog.Stateful.Linq Assembly Hedgehog.Stateful.dll Extension methods for working with specifications in C#. F# C# type SpecificationExtensions = member ToPropertyWith : spec:ParallelSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> * disposeSut:Action<'TSystem> -> Property<unit> member ToPropertyWith : spec:ParallelSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> -> Property<unit> member ToPropertyWith : spec:SequentialSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> * disposeSut:Action<'TSystem> -> Property<unit> member ToPropertyWith : spec:SequentialSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> -> Property<unit> public class SpecificationExtensions { public static Property<void> ToPropertyWith(this ParallelSpecification<TSystem, TState> spec, Func<TSystem> createSut, Action<TSystem> disposeSut) public static Property<void> ToPropertyWith(this ParallelSpecification<TSystem, TState> spec, Func<TSystem> createSut) public static Property<void> ToPropertyWith(this SequentialSpecification<TSystem, TState> spec, Func<TSystem> createSut, Action<TSystem> disposeSut) public static Property<void> ToPropertyWith(this SequentialSpecification<TSystem, TState> spec, Func<TSystem> createSut) } Methods ToPropertyWith Convert a parallel specification to a property using a SUT factory with explicit dispose. The factory is called once per property test run to create a fresh SUT. The dispose action is called after each test run completes (even if the test fails). Parameters: spec: The parallel specification. createSut: A Func delegate that creates a new SUT instance for each test run. disposeSut: An Action delegate that disposes the SUT after each test run. F# C# member ToPropertyWith : spec:ParallelSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> * disposeSut:Action<'TSystem> -> Property<unit> public static Property<void> ToPropertyWith(this ParallelSpecification<TSystem, TState> spec, Func<TSystem> createSut, Action<TSystem> disposeSut) ToPropertyWith Convert a parallel specification to a property using a SUT factory. The factory is called once per property test run to create a fresh SUT. If the SUT implements IDisposable, it will be disposed after each test run. This is the recommended approach to ensure test isolation. Parameters: spec: The parallel specification. createSut: A Func delegate that creates a new SUT instance for each test run. F# C# member ToPropertyWith : spec:ParallelSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> -> Property<unit> public static Property<void> ToPropertyWith(this ParallelSpecification<TSystem, TState> spec, Func<TSystem> createSut) ToPropertyWith Convert a sequential specification to a property using a SUT factory with explicit dispose. The factory is called once per property test run to create a fresh SUT. The dispose action is called after each test run completes (even if the test fails). Parameters: spec: The sequential specification. createSut: A Func delegate that creates a new SUT instance for each test run. disposeSut: An Action delegate that disposes the SUT after each test run. F# C# member ToPropertyWith : spec:SequentialSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> * disposeSut:Action<'TSystem> -> Property<unit> public static Property<void> ToPropertyWith(this SequentialSpecification<TSystem, TState> spec, Func<TSystem> createSut, Action<TSystem> disposeSut) ToPropertyWith Convert a sequential specification to a property using a SUT factory. The factory is called once per property test run to create a fresh SUT. If the SUT implements IDisposable, it will be disposed after each test run. This is the recommended approach to ensure test isolation. Parameters: spec: The sequential specification. createSut: A Func delegate that creates a new SUT instance for each test run. F# C# member ToPropertyWith : spec:SequentialSpecification<'TSystem, 'TState> * createSut:Func<'TSystem> -> Property<unit> public static Property<void> ToPropertyWith(this SequentialSpecification<TSystem, TState> spec, Func<TSystem> createSut)"
  },
  "api/Hedgehog.Stateful.Linq.VarExtensions.html": {
    "href": "api/Hedgehog.Stateful.Linq.VarExtensions.html",
    "title": "Class VarExtensions | Hedgehog.Stateful",
    "summary": "Class VarExtensions Namespace Hedgehog.Stateful.Linq Assembly Hedgehog.Stateful.dll Extension methods for working with Var<T> in C#. F# C# type VarExtensions = member Select : var:Var<'T> * selector:Func<'T, 'U> -> Var<'U> public class VarExtensions { public static Var<U> Select(this Var<T> var, Func<T, U> selector) } Methods Select Projects the value of a variable using a selector function. This allows extracting fields from structured command outputs. Parameters: var: The variable to project from. selector: A function to apply to the variable's value. F# C# member Select : var:Var<'T> * selector:Func<'T, 'U> -> Var<'U> public static Var<U> Select(this Var<T> var, Func<T, U> selector)"
  },
  "api/Hedgehog.Stateful.Name.html": {
    "href": "api/Hedgehog.Stateful.Name.html",
    "title": "Class Name | Hedgehog.Stateful",
    "summary": "Class Name Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Unique identifier for a symbolic variable. F# C# type Name public class Name"
  },
  "api/Hedgehog.Stateful.Parallel.html": {
    "href": "api/Hedgehog.Stateful.Parallel.html",
    "title": "Class Parallel | Hedgehog.Stateful",
    "summary": "Class Parallel Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll F# C# type Parallel public class Parallel"
  },
  "api/Hedgehog.Stateful.ParallelSpecification_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.ParallelSpecification_TSystem, TState_.html",
    "title": "Class ParallelSpecification<'TSystem, 'TState> | Hedgehog.Stateful",
    "summary": "Class ParallelSpecification<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Abstract base class for parallel state machine tests. Tests concurrent execution by running two branches in parallel after a sequential prefix. The SUT (System Under Test) is created externally and passed to Check/ToProperty methods. F# C# type ParallelSpecification<'TSystem, 'TState> = abstract member BranchRange : Range<int> abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract member Commands : ICommand<'TSystem, 'TState> array abstract member InitialState : 'TState abstract member PrefixRange : Range<int> abstract member SetupCommands : ICommand<'TSystem, 'TState> array member ToProperty : 'TSystem -> Property<unit> member ToPropertyWith : createSut:unit -> 'TSystem * disposeSut:'TSystem -> unit -> Property<unit> member ToPropertyWith : unit -> 'TSystem -> Property<unit> public class ParallelSpecification<TSystem, TState> { abstract Range<int> BranchRange() abstract ICommand<TSystem, TState> array CleanupCommands() abstract ICommand<TSystem, TState> array Commands() abstract TState InitialState() abstract Range<int> PrefixRange() abstract ICommand<TSystem, TState> array SetupCommands() public static Property<void> ToProperty(TSystem sut) public static Property<void> ToPropertyWith(void -> TSystem createSut, TSystem -> void disposeSut) public static Property<void> ToPropertyWith(void -> TSystem createSut) } Methods ToProperty Convert this specification to a property that can be checked. Parameters: sut: The system under test (SUT) instance to use for the test run. F# C# member ToProperty : 'TSystem -> Property<unit> public static Property<void> ToProperty(TSystem sut) ToPropertyWith Convert this specification to a property using a SUT factory with explicit dispose. The factory is called once per property test run to create a fresh SUT. The dispose function is called after each test run completes (even if the test fails). Parameters: createSut: A function that creates a new SUT instance for each test run. disposeSut: A function that disposes the SUT after each test run. F# C# member ToPropertyWith : createSut:unit -> 'TSystem * disposeSut:'TSystem -> unit -> Property<unit> public static Property<void> ToPropertyWith(void -> TSystem createSut, TSystem -> void disposeSut) ToPropertyWith Convert this specification to a property using a SUT factory. The factory is called once per property test run to create a fresh SUT. If the SUT implements IDisposable, it will be disposed after each test run. This is the recommended approach to ensure test isolation. Parameters: createSut: A function that creates a new SUT instance for each test run. F# C# member ToPropertyWith : unit -> 'TSystem -> Property<unit> public static Property<void> ToPropertyWith(void -> TSystem createSut) BranchRange Range of branch sequence lengths to generate (parallel actions in each branch). F# C# abstract member BranchRange : Range<int> abstract Range<int> BranchRange() InitialState The initial model state. F# C# abstract member InitialState : 'TState abstract TState InitialState() Commands Commands that operate on the SUT during the test sequence. The SUT is passed as a typed parameter to Execute methods. F# C# abstract member Commands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array Commands() PrefixRange Range of prefix sequence lengths to generate (sequential actions before parallel execution). F# C# abstract member PrefixRange : Range<int> abstract Range<int> PrefixRange() SetupCommands Setup commands that execute before the prefix and parallel branches. These commands are generated (parameters can shrink) but always execute in the order specified. Setup commands cannot be shrunk away from the action sequence. Default is an empty list (no setup). F# C# abstract member SetupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array SetupCommands() CleanupCommands Cleanup commands that execute after the parallel branches complete. These commands are generated (parameters can shrink) but always execute in the order specified. Cleanup commands cannot be shrunk away and are guaranteed to run even if tests fail. Cleanup is generated using the state after prefix (before parallel execution). Default is an empty list (no cleanup). F# C# abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array CleanupCommands()"
  },
  "api/Hedgehog.Stateful.Sequential.html": {
    "href": "api/Hedgehog.Stateful.Sequential.html",
    "title": "Class Sequential | Hedgehog.Stateful",
    "summary": "Class Sequential Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll F# C# type Sequential public class Sequential"
  },
  "api/Hedgehog.Stateful.SequentialSpecification_TSystem, TState_.html": {
    "href": "api/Hedgehog.Stateful.SequentialSpecification_TSystem, TState_.html",
    "title": "Class SequentialSpecification<'TSystem, 'TState> | Hedgehog.Stateful",
    "summary": "Class SequentialSpecification<'TSystem, 'TState> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Abstract base class for sequential state machine tests. The SUT (System Under Test) is created externally and passed to Check/ToProperty methods. Setup and cleanup are modeled as command lists that execute before/after test actions. F# C# type SequentialSpecification<'TSystem, 'TState> = abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract member Commands : ICommand<'TSystem, 'TState> array abstract member InitialState : 'TState abstract member Range : Range<int> abstract member SetupCommands : ICommand<'TSystem, 'TState> array member ToProperty : 'TSystem -> Property<unit> member ToPropertyWith : createSut:unit -> 'TSystem * disposeSut:'TSystem -> unit -> Property<unit> member ToPropertyWith : unit -> 'TSystem -> Property<unit> public class SequentialSpecification<TSystem, TState> { abstract ICommand<TSystem, TState> array CleanupCommands() abstract ICommand<TSystem, TState> array Commands() abstract TState InitialState() abstract Range<int> Range() abstract ICommand<TSystem, TState> array SetupCommands() public static Property<void> ToProperty(TSystem sut) public static Property<void> ToPropertyWith(void -> TSystem createSut, TSystem -> void disposeSut) public static Property<void> ToPropertyWith(void -> TSystem createSut) } Methods ToProperty Convert this specification to a property that can be checked. Parameters: sut: The system under test (SUT) instance to use for the test run. F# C# member ToProperty : 'TSystem -> Property<unit> public static Property<void> ToProperty(TSystem sut) ToPropertyWith Convert this specification to a property using a SUT factory with explicit dispose. The factory is called once per property test run to create a fresh SUT. The dispose function is called after each test run completes (even if the test fails). Parameters: createSut: A function that creates a new SUT instance for each test run. disposeSut: A function that disposes the SUT after each test run. F# C# member ToPropertyWith : createSut:unit -> 'TSystem * disposeSut:'TSystem -> unit -> Property<unit> public static Property<void> ToPropertyWith(void -> TSystem createSut, TSystem -> void disposeSut) ToPropertyWith Convert this specification to a property using a SUT factory. The factory is called once per property test run to create a fresh SUT. If the SUT implements IDisposable, it will be disposed after each test run. This is the recommended approach to ensure test isolation. Parameters: createSut: A function that creates a new SUT instance for each test run. F# C# member ToPropertyWith : unit -> 'TSystem -> Property<unit> public static Property<void> ToPropertyWith(void -> TSystem createSut) InitialState The initial model state. F# C# abstract member InitialState : 'TState abstract TState InitialState() Range Range of action sequence lengths to generate. F# C# abstract member Range : Range<int> abstract Range<int> Range() Commands Commands that operate on the SUT during the test sequence. The SUT is passed as a typed parameter to Execute methods. F# C# abstract member Commands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array Commands() SetupCommands Setup commands that execute before the test sequence. These commands are generated (parameters can shrink) but always execute in the order specified. Setup commands cannot be shrunk away from the action sequence. Default is an empty list (no setup). F# C# abstract member SetupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array SetupCommands() CleanupCommands Cleanup commands that execute after the test sequence. These commands are generated (parameters can shrink) but always execute in the order specified. Cleanup commands cannot be shrunk away and are guaranteed to run even if tests fail. Cleanup is generated using the final state after setup and test actions complete. Default is an empty list (no cleanup). F# C# abstract member CleanupCommands : ICommand<'TSystem, 'TState> array abstract ICommand<TSystem, TState> array CleanupCommands()"
  },
  "api/Hedgehog.Stateful.Var.html": {
    "href": "api/Hedgehog.Stateful.Var.html",
    "title": "Class Var | Hedgehog.Stateful",
    "summary": "Class Var Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll F# C# type Var = member symbolic : 'T -> Var<'T> public class Var { public static Var<T> symbolic(T defaultValue) } Methods symbolic Initialise a symbolic (unbound) variable with a default value for the initial state. A symbolic variable is not yet bound to a generated value and is used to represent a placeholder in the model before generation or binding occurs. Parameters: defaultValue: The default value to assign to the variable. F# C# member symbolic : 'T -> Var<'T> public static Var<T> symbolic(T defaultValue)"
  },
  "api/Hedgehog.Stateful.Var_T_.html": {
    "href": "api/Hedgehog.Stateful.Var_T_.html",
    "title": "Class Var<'T> | Hedgehog.Stateful",
    "summary": "Class Var<'T> Namespace Hedgehog.Stateful Assembly Hedgehog.Stateful.dll Symbolic variable referencing a command's output. Symbolic variables are placeholders that let us chain commands by using one command's result as input to another, even before execution. A symbolic variable is not yet bound to a generated value and is used to represent a value in the model before binding occurs. F# C# type Var<'T> = member Resolve : Env -> 'T member ResolveOr : env:Env * fallback:'T -> 'T member TryResolve : env:Env * value:byref<'T> -> bool public class Var<T> { public static T Resolve(Env env) public static T ResolveOr(Env env, T fallback) public static bool TryResolve(Env env, byref<T> value) } Methods Resolve Resolve the variable using its default if not found in the environment. Parameters: env: The environment to resolve the variable from. F# C# member Resolve : Env -> 'T public static T Resolve(Env env) ResolveOr Resolve the variable with an explicit fallback value, overriding the variable's default. Parameters: env: The environment to resolve the variable from. fallback: The fallback value to use if the variable is not found. F# C# member ResolveOr : env:Env * fallback:'T -> 'T public static T ResolveOr(Env env, T fallback) TryResolve Attempts to resolve a variable from the environment. Parameters: env: The environment to resolve the variable from. value: When this method returns, contains the resolved value if successful; otherwise, the default value for the type. F# C# member TryResolve : env:Env * value:byref<'T> -> bool public static bool TryResolve(Env env, byref<T> value)"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Hedgehog.Stateful",
    "summary": "API Documentation For F# Users To use Hedgehog.Stateful import the following namespaces and read the relevant API documentation: F# C# open Hedgehog open Hedgehog.FSharp open Hedgehog.Stateful Command<'TSystem, 'TState, 'TInput, 'TOutput> SequentialSpecification<'TSystem, 'TState> using Hedgehog; using Hedgehog.Linq; using Hedgehog.Stateful; using Hedgehog.Stateful.Linq; Hedgehog.System.Command<TSystem, TState, TInput, TOutput> Hedgehog.System.SequentialSpecification<TSystem, TState>"
  },
  "index.html": {
    "href": "index.html",
    "title": "What is stateful testing? | Hedgehog.Stateful",
    "summary": "What is stateful testing? Most property-based tests check individual operations in isolation: \"if I sort this list, is it actually sorted?\" But real systems have state that changes over time. A user logs in, makes changes, logs out. A door locks and unlocks. A shopping cart adds and removes items. Stateful testing lets you test sequences of actions on systems that maintain state. Instead of testing one operation at a time, you define each possible action as a Command. Hedgehog then generates random sequences of these commands - essentially, complete scenarios of how your system might be used. When something goes wrong, Hedgehog automatically shrinks both the sequence of actions and their parameters to find you the minimal failing case. Imagine testing a login system. Instead of manually writing test cases like \"login, then logout\" or \"login, change password, logout,\" Hedgehog generates hundreds of different sequences and finds edge cases you never thought of—like what happens when you try to change a password twice in a row, or logout when already logged out. Building blocks: Commands Let's build up the idea step by step. We'll use pseudocode to focus on concepts rather than specific syntax. Step 1: Naming your command Every command needs a name for clarity: Command { Name: \"LogIn\" } Step 2: Defining preconditions Here's where stateful testing gets interesting. Not all commands make sense at all times. You can't log out if you're not logged in. You can't lock a door that's already locked. We track this with a model state—a simple state representing what we know from interacting with the system. Commands can check this state and decide whether they're allowed to run: Command { Name: \"LogOut\" Precondition(currentState): currentState.isLoggedIn // Only generate when logged in } This way, Hedgehog only generates valid sequences. The LogOut command appears only when the user is logged in (when Precondition returns true). The LockDoor command appears only when the door is unlocked. Step 3: Generating command inputs Just like regular property tests, commands need test data. Each command defines how to generate its input: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() } Step 4: Executing the command Now we need to actually run the command against the real system: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() Execute(input): actualSystem.login(input.username) } The Execute method takes the generated input and performs the actual operation, returning whatever the system returns. Step 5: Updating the model state After executing a command, we need to update our model state to reflect what happened: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() Execute(input): actualSystem.login(input.username) UpdateState(oldState, input, output): oldState with { isLoggedIn: true, username: input.username } } This method takes the old state, the input we used, and the output we got, and produces the new state. Step 6: Making assertions Finally, we need to verify that the system behaved correctly. The Ensure method checks whether everything went as expected: Command { Name: \"LogIn\" Precondition(currentState): currentState.isLoggedIn Generate(currentState): generateRandomUsername() Execute(input): actualSystem.login(input.username) UpdateState(oldState, input, output): oldState with { isLoggedIn: true, username: input.username } Ensure(oldState, newState, input, output): assert output.success == true assert output.username == input.username } With both states available, you can make rich assertions: \"after logging in, the user should be logged in,\" \"after adding an item, the cart count should increase by one,\" and so on. Putting it all together Define all your commands (LogIn, LogOut, ChangePassword, etc.), and Hedgehog will: Generate random sequences of commands Check preconditions to ensure valid sequences Execute each command against your real system Update the model state after each command Assert that everything worked correctly If something fails, shrink the sequence to find the minimal reproduction case You get comprehensive testing of complex stateful scenarios with minimal effort, and when bugs appear, you get a short, clear sequence showing exactly how to reproduce them."
  },
  "stateful/commands.html": {
    "href": "stateful/commands.html",
    "title": "Commands | Hedgehog.Stateful",
    "summary": "Commands Commands are the heart of stateful testing. Each command represents a single operation you can perform on your system - like opening a door, adding an item to a cart, or incrementing a counter. Hedgehog then uses these individual actions (commands) to build up valid sequences that simulate client's behaviour. This page dives deep into the Command interface, explaining how commands work, when they execute, and how to use state to chain operations together. Why Two Phases? Generation vs Execution Hedgehog's stateful testing uses a two-phase approach: generation and execution. This might seem like unnecessary complexity at first—why not just generate and execute commands in one step? The answer lies in efficiency and effective shrinking. The Problem Without Separation Imagine if we generated commands by executing them directly against your system: No way to pre-validate sequences: We'd discover invalid sequences only during execution—wasting time running operations that don't make sense (like unlocking an already unlocked door) Expensive shrinking: When a test fails, Hedgehog tries hundreds of smaller variations to find the minimal failing case. Without pre-validation, each shrunk sequence would need to execute against your real system, even if it's obviously invalid (like trying to pop from an empty stack). We can (and should!) do a runtime check and simply ignore invalid steps at runtime, but the effort to get to that point is still wasted External dependencies: Your system might involve databases, network calls, or rate-limited APIs. Executing invalid sequences during shrinking would waste resources and time The Solution: Symbolic Execution During Generation By separating generation from execution, Hedgehog can: Build structurally valid sequences using only the model state, without touching your real system Reject invalid shrink attempts immediately by checking preconditions symbolically Only execute sequences that make sense, minimizing load on your system Here's how it works: Generation phase (fast, no SUT calls): Build a sequence by checking Precondition against the model state Update state symbolically using Var<T> placeholders for outputs Shrinking can try hundreds of variations, rejecting invalid ones instantly Execution phase (only valid sequences): Check Require with concrete values from the environment Actually call your system's methods Verify results with Ensure Example: The Efficiency Gain Consider testing a stack with Push and Pop commands. During shrinking, Hedgehog might try: Original (fails): Push(1), Push(2), Push(3), Pop, Pop, Pop, BuggyOperation Shrink attempt 1: Pop, Pop, Pop, BuggyOperation ← REJECTED at generation (can't pop empty stack) Shrink attempt 2: Push(1), Pop, Pop, BuggyOperation ← REJECTED at generation (second pop invalid) Shrink attempt 3: Push(1), BuggyOperation ← EXECUTED (valid sequence) Without symbolic execution, all three shrink attempts would execute against your real stack. With it, only the third attempt needs to touch your system—the first two are rejected instantly during generation. This separation is especially valuable for: Systems with external dependencies (databases, APIs, file systems) Expensive operations (network calls, complex computations) Rate-limited services (each wasted execution burns quota) Parallel testing (where invalid interleavings can be rejected without execution) Understanding State State is shared throughout both phases of testing: first during generation (when Hedgehog builds up a series of commands to execute), and then during execution (when those commands actually run against your system). The key insight is that some parts of the state can be known during generation, while others only become known during execution: Known at generation time: When generating a sequence that includes LockDoorCommand, we know the door will be \" Locked\" for the next action in the sequence - even before executing anything. This is concrete state. Known only at execution time: If the system returns a lock code when the door is locked, we know that a code exists during generation, but the actual value is only available after execution. This is symbolic state. We represent concrete state using regular properties (like bool IsLocked), and symbolic state using the Var<T> type (like Var<string> LockCode). Here's an example of a door state that combines both: F# C# type DoorState = { IsLocked: bool // Concrete: we know immediately after LockDoor LockCode: Var<string> // Symbolic: actual code only known after execution } public record DoorState { public bool IsLocked { get; init; } // Concrete: we know immediately after LockDoor public Var<string> LockCode { get; init; } // Symbolic: actual code only known after execution } The key rule: At generation time, you can only access the concrete parts of the state. You cannot resolve symbolic variables because execution hasn't happened yet! The Command Interface Every command inherits from Command<TSystem, TState, TInput, TOutput> and implements these methods: F# C# type MyCommand() = inherit Command<MySystem, MyState, MyInput, MyOutput>() // 1. Name for reporting override _.Name = \"MyCommand\" // 2. Should this command be generated in this state? override _.Precondition(state) = true // 3. Generate input for this command override _.Generate(state) = Gen.int32 (Range.linear 0 100) // 4. Should we execute this command with these inputs? override _.Require(env, state, input) = true // 5. Execute the real operation override _.Execute(sut, env, state, input) = let result = sut.DoSomething(input) Task.FromResult(result) // 6. Update the model state override _.Update(state, input, outputVar) = { state with Value = outputVar } // 7. Verify the result is correct override _.Ensure(env, oldState, newState, input, output) = // Check output matches expectations true public class MyCommand : Command<MySystem, MyState, MyInput, MyOutput> { // 1. Name for reporting public override string Name => \"MyCommand\"; // 2. Should this command be generated in this state? public override bool Precondition(MyState state) => true; // 3. Generate input for this command public override Gen<MyInput> Generate(MyState state) => Gen.Int32(Range.LinearInt32(0, 100)); // 4. Should we execute this command with these inputs? public override bool Require(Env env, MyState state, MyInput input) => true; // 5. Execute the real operation public override Task<MyOutput> Execute(MySystem sut, Env env, MyState state, MyInput input) { var result = sut.DoSomething(input); return Task.FromResult(result); } // 6. Update the model state public override MyState Update(MyState state, MyInput input, Var<MyOutput> outputVar) => state with { Value = outputVar }; // 7. Verify the result is correct public override bool Ensure(Env env, MyState oldState, MyState newState, MyInput input, MyOutput output) => // Check output matches expectations true; } Let's understand each piece and how they work together. Understanding Env The Env (environment) is a key concept that allows you to resolve symbolic state values into concrete values, giving you access to the real execution-time values. Methods with Env (can resolve symbolic values): Require - Check preconditions using actual runtime values Execute - Perform operations using resolved values Ensure - Verify results using actual values Methods without Env (can only access concrete state): Generate - Only has access to structural/concrete state Update - Works with symbolic variables, doesn't resolve them During sequence generation, symbolic values don't have concrete runtime values yet, so Generate and Update cannot receive an Env. However, during execution, Require, Execute, and Ensure all receive an Env that lets you resolve any Var<T> to its actual runtime value. The Command Lifecycle When Hedgehog builds and executes a test sequence, each command goes through two distinct phases. Understanding this lifecycle is key to grasping how stateful testing achieves efficiency. Phase 1: Generation (Symbolic Execution) During generation, Hedgehog builds a sequence of commands without touching your real system. This happens once during initial generation and potentially hundreds of times during shrinking. For each command in sequence: 1. Precondition → Should we include this command? (checks structural state only - no Env) 2. Generate → Generate random input for this command (only if Precondition returns true) 3. Update → Update model state symbolically (enables next command's Precondition check) Key insight: The Update method runs during generation to evolve the model state. This lets subsequent commands in the sequence check their Precondition against the updated state. For example, after a LockDoorCommand, the state shows IsLocked = true, so UnlockDoorCommand knows it can be included next. During shrinking: When a test fails, Hedgehog tries removing commands or shrinking their inputs. For each shrink attempt, it re-runs this generation phase to validate the sequence without executing anything. Invalid sequences ( like trying to pop from an empty stack) are rejected instantly based on Precondition checks—no SUT calls needed! Phase 2: Execution (Real Operations) Once we have a valid sequence, execution runs exactly once against your real system: For each command in sequence: 1. Require → Runtime check: can we execute with these concrete values? (has Env - can resolve symbolic values) 2. Execute → Run the actual operation on the real system 3. Update → Update model state symbolically (same method as generation, now env has real values) 4. Ensure → Verify the result matches our expectations Why Require? Even though the sequence passed generation validation, some commands might reference symbolic variables that didn't get bound (because earlier commands were skipped). The Require method lets you verify that all needed values are actually available before executing. The efficiency payoff: By the time we reach execution, we know the sequence is structurally valid. We avoid wasting time (and API calls, database operations, etc.) on sequences that would obviously fail. 1. Precondition: Deciding Whether to Generate When it runs: During test generation, before execution Purpose: Decide whether this command makes sense based on the concrete structure of the state Returns: true to include the command (and call Generate), false to skip this command Critical: You can only access concrete parts of the state here. No Env means no resolving symbolic variables! For example, checking a simple boolean: F# C# type DoorState = { IsLocked: bool // Concrete value we can check } type KnockKnockDoorCommand() = inherit Command<Door, DoorState, int, bool>() override _.Name = \"KnockKnock\" override _.Precondition(state) = // Check concrete state directly - no Env needed! state.IsLocked // Only generate when door is locked override _.Generate(state) = // Generate the number of knocks Gen.int32 (Range.linear 1 5) public record DoorState { public bool IsLocked { get; init; } // Concrete value we can check } public class KnockKnockDoorCommand : Command<Door, DoorState, int, bool> { public override string Name => \"KnockKnock\"; public override bool Precondition(DoorState state) { // Check concrete state directly - no Env needed! return state.IsLocked; // Only generate when door is locked } public override Gen<int> Generate(DoorState state) { // Generate the number of knocks return Gen.Int32(Range.LinearInt32(1, 5)); } } Key insight: At generation time, you only know the structure - \"the door is locked\", \"the stack has 3 items\" - but not the actual values like \"the lock code is 1234\" or \"the top item is 42\". Those require execution. 2. Generate: Creating Command Input When it runs: During test generation, after Precondition returns true Purpose: Generate random input for this command Returns: A Gen<TInput> generator that produces input values Important: This is only called when Precondition returns true, so you can assume the structural preconditions are already satisfied. 3. Require: Runtime Precondition Check When it runs: Just before execution, after the sequence is generated Purpose: Verify that the command can still be executed with these specific inputs. Returns: true to proceed with execution, false to skip this command (the test continues with remaining commands) Important: Returning false does NOT fail the test - it simply skips the command. This is different from Ensure, which validates correctness. Key difference from Precondition: Require DOES receive an Env parameter, so it CAN resolve symbolic variables! This is where you check concrete runtime values that weren't known during generation. When you need it: The most common case is when your Generate method returns Var<T> as part of the input (e.g., picking from a list of symbolic IDs). Since previous commands can be skipped, those symbolic variables might not be bound at execution time. Override Require to check if such variables can actually be resolved before attempting to use them. \uD83D\uDCA1 Tip: For a detailed explanation of when and how to use Require, including complete examples with symbolic variables in inputs, see Runtime Preconditions. In practice: The default Require implementation returns true, which works for most commands that don't use symbolic variables as input. 4. Execute: Running the Real Operation When it runs: During test execution Purpose: Perform the actual operation on your system under test Returns: A Task<TOutput> with the result This is straightforward - call your system's method and return the result: F# C# override _.Execute(sut, env, state, input) = let result = sut.IncrementCounter() Task.FromResult(result) public override Task<int> Execute(Counter sut, Env env, CounterState state, bool input) { var result = sut.Increment(); return Task.FromResult(result); } Important: The Execute method receives: sut: Your system under test (the real object) env: The environment with resolved values from previous commands state: The current model state input: The generated input for this command Use env to resolve any symbolic variables you need from the state: F# C# override _.Execute(sut, env, state, input) = let code = state.LockCode.Resolve(env) sut.UnlockDoorAsync(code, input) public override Task<bool> Execute(Door sut, Env env, DoorState state, string input) { var code = state.LockCode.Resolve(env); return sut.UnlockDoorAsync(code, input); } 5. Update: Tracking Symbolic State When it runs: During both generation and execution phases - after each command in the sequence Purpose: Update your model state with the new symbolic output to evolve the structural state Returns: The new state Critical insight: Update is called during generation (before any real execution happens) to maintain the structural state. This allows subsequent commands in the sequence to evaluate their Precondition based on the evolved state. During execution, these variables are bound to actual runtime values in the Env. This is where you store the command's output as a symbolic variable (Var<TOutput>) that future commands can reference: F# C# override _.Update(state, input, outputVar) = { state with CurrentCount = outputVar } public override CounterState Update(CounterState state, bool input, Var<int> outputVar) => state with { CurrentCount = outputVar }; The outputVar is a symbolic reference to this command's output. Later commands can resolve it to get the actual value. Projecting Fields from Structured Outputs When a command returns a structured type (like a record or class), you often want to store individual fields in your state rather than the entire object. Use Var.map (F#) or .Select() (C#) to project fields from the output: F# C# // Command that returns a structured Person type type Person = { Name: string Age: int } type RegistryState = { LastPersonName: Var<string> LastPersonAge: Var<int> } type AddPersonCommand() = inherit Command<PersonRegistry, RegistryState, string * int, Person>() override _.Execute(sut, env, state, (name, age)) = let person = sut.AddPerson(name, age) Task.FromResult(person) // Project individual fields from the Person output override _.Update(state, input, personVar) = { LastPersonName = Var.map (fun p -> p.Name) personVar LastPersonAge = Var.map (fun p -> p.Age) personVar } // Command that returns a structured Person type public record Person(string Name, int Age); public record RegistryState { public Var<string> LastPersonName { get; init; } public Var<int> LastPersonAge { get; init; } } public class AddPersonCommand : Command<PersonRegistry, RegistryState, (string, int), Person> { public override Task<Person> Execute(PersonRegistry sut, Env env, RegistryState state, (string, int) input) { var (name, age) = input; var person = sut.AddPerson(name, age); return Task.FromResult(person); } // Project individual fields from the Person output public override RegistryState Update(RegistryState state, (string, int) input, Var<Person> personVar) => state with { LastPersonName = personVar.Select(p => p.Name), LastPersonAge = personVar.Select(p => p.Age) }; } How it works: Both projected variables (LastPersonName and LastPersonAge) share the same underlying variable name - they point to the same Person object in the environment. When you resolve them, the projection function is applied to extract the specific field. You can chain projections: F# C# override _.Update(state, input, personVar) = let nameVar = Var.map (fun p -> p.Name) personVar let nameLengthVar = Var.map String.length nameVar { state with NameLength = nameLengthVar } public override RegistryState Update(RegistryState state, (string, int) input, Var<Person> personVar) { var nameVar = personVar.Select(p => p.Name); var nameLengthVar = nameVar.Select(name => name.Length); return state with { NameLength = nameLengthVar }; } This is particularly useful when you need to pass different parts of a command's output to different subsequent commands. 6. Ensure: Verifying Correctness When it runs: After execution and state update Purpose: Assert that the output matches expectations Returns: true if the assertion passes, false or throw an exception if it fails This is your postcondition check: F# C# override _.Ensure(env, oldState, newState, input, output) = let oldCount = oldState.CurrentCount.Resolve(env) output = oldCount + 1 // Increment should increase by exactly 1 public override bool Ensure(Env env, CounterState oldState, CounterState newState, bool input, int output) { var oldCount = oldState.CurrentCount.Resolve(env); return output == oldCount + 1; // Increment should increase by exactly 1 } You can also throw exceptions for more detailed error messages: F# C# override _.Ensure(env, oldState, newState, input, output) = let oldCount = oldState.CurrentCount.Resolve(env) if output <> oldCount + 1 then failwith $\"Expected {oldCount + 1}, got {output}\" true public override bool Ensure(Env env, CounterState oldState, CounterState newState, bool input, int output) { var oldCount = oldState.CurrentCount.Resolve(env); Assert.Equal(output, oldCount + 1); return true; } Commands Without Outputs Sometimes operations don't return meaningful values - they just perform side effects. For these, use ActionCommand<TSystem, TState, TInput>: F# C# type CloseConnectionCommand() = inherit ActionCommand<Database, DbState, unit>() override _.Name = \"CloseConnection\" override _.Precondition(state) = true override _.Generate(state) = Gen.constant () override _.Execute(sut, env, state, input) = sut.CloseConnection() Task.CompletedTask // No return value override _.Update(state, input) = { state with IsConnected = false } // No output var override _.Ensure(env, oldState, newState, input) = // Verify side effect without checking output true public class CloseConnectionCommand : ActionCommand<Database, DbState, NoValue> { public override string Name => \"CloseConnection\"; public override bool Precondition(DbState state) => true; public override Gen<NoValue> Generate(DbState state) => Gen.Constant(NoValue.Value); public override Task Execute(Database sut, Env env, DbState state, NoValue input) { sut.CloseConnection(); return Task.CompletedTask; // No return value } public override DbState Update(DbState state, NoValue input) => state with { IsConnected = false }; // No output var public override bool Ensure(Env env, DbState oldState, DbState newState, NoValue input) => true; }"
  },
  "stateful/complete-example.html": {
    "href": "stateful/complete-example.html",
    "title": "Complete Example: Testing a Counter | Hedgehog.Stateful",
    "summary": "Complete Example: Testing a Counter This walkthrough will guide you through building a complete stateful test from scratch. We'll test a simple Counter class with increment, decrement, and reset operations. The System Under Test (SUT) Let's start with a simple counter implementation: F# C# type Counter() = let mutable value = 0 member _.Increment() = value <- value + 1 member _.Decrement() = value <- value - 1 member _.Reset() = value <- 0 member _.Get() = value public sealed class Counter { private int _value; public void Increment() => _value++; public void Decrement() => _value--; public void Reset() => _value = 0; public int Get() => _value; } This is our System Under Test (SUT). It maintains state (the current count) and provides operations that modify that state. The Model State To test our counter, we need a model that represents what we expect the counter's state to be. Since our counter has a single integer value, our model is simple: F# C# type CounterState = { CurrentCount: Var<int> // Symbolic reference to the counter's value } public record CounterState { public required Var<int> CurrentCount { get; init; } } The Var<int> is a symbolic variable—it represents \"the value that operation X returned.\" This lets us track relationships between operations even before we know their concrete values. Defining Commands Now we'll define each operation as a Command. Each command inherits from Command<TSystem, TState, TInput, TOutput> where: TSystem is our system under test type (Counter) TState is our model state type (CounterState) TInput is the input parameter type for this command TOutput is what the command returns The Increment Command F# C# type IncrementCommand() = inherit Command<Counter, CounterState, unit, int>() // Name for debugging/shrinking output override _.Name = \"Increment\" // Always allow this command override _.Precondition(state) = true // Execute the real operation on the SUT override _.Execute(counter, env, state, input) = counter.Increment() let result = counter.Get() Task.FromResult(result) // Generate inputs (none needed for increment) override _.Generate(state) = Gen.constant () // Update our model state with the new value override _.Update(state, input, outputVar) = { CurrentCount = outputVar } // Assert the result is correct override _.Ensure(env, oldState, newState, input, result) = let oldCount = oldState.CurrentCount.Resolve(env) result = oldCount + 1 public class IncrementCommand : Command<Counter, CounterState, NoValue, int> { // Name for debugging/shrinking output public override string Name => \"Increment\"; // Always allow this command public override bool Precondition(CounterState state) => true; // Execute the real operation on the SUT public override Task<int> Execute(Counter sut, Env env, CounterState state, NoValue input) { sut.Increment(); var result = sut.Get(); return Task.FromResult(result); } // Generate inputs (none needed for increment) public override Gen<NoValue> Generate(CounterState state) => Gen.Constant(NoValue.Value); // Update our model state with the new value public override CounterState Update(CounterState state, NoValue input, Var<int> outputVar) => state with { CurrentCount = outputVar }; // Assert the result is correct public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoValue input, int result) { var oldCount = oldState.CurrentCount.Resolve(env); return result == oldCount + 1; } } Let's break down each method: Name: Used in test output to show which command failed Precondition: Determines if this command can be generated in the current state (always true for simple commands) Execute: Runs the actual operation and returns the new count Generate: Generates random inputs (we use unit in F# or NoValue in C# since increment needs no meaningful input) Update: Takes the output and creates the new model state Ensure: Verifies the result is what we expected (old count + 1) The Decrement Command The decrement command is almost identical: F# C# type DecrementCommand() = inherit Command<Counter, CounterState, unit, int>() override _.Name = \"Decrement\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = counter.Decrement() let result = counter.Get() Task.FromResult(result) override _.Generate _ = Gen.constant () override _.Update(_, _, outputVar) = { CurrentCount = outputVar } override _.Ensure(env, oldState, newState, input, result) = let oldCount = oldState.CurrentCount.Resolve(env) result = oldCount - 1 // Should decrease by 1 public class DecrementCommand : Command<Counter, CounterState, NoValue, int> { public override string Name => \"Decrement\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, CounterState state, NoValue input) { sut.Decrement(); var result = sut.Get(); return Task.FromResult(result); } public override Gen<NoValue> Generate(CounterState state) => Gen.Constant(NoValue.Value); public override CounterState Update(CounterState state, NoValue input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoValue input, int result) { var oldCount = oldState.CurrentCount.Resolve(env); return result == oldCount - 1; // Should decrease by 1 } } The Reset Command Reset is interesting because it doesn't depend on the previous state: F# C# type ResetCommand() = inherit Command<Counter, CounterState, unit, int>() override _.Name = \"Reset\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = counter.Reset() let result = counter.Get() Task.FromResult(result) override _.Generate(state) = Gen.constant () override _.Update(state, input, outputVar) = { CurrentCount = outputVar } override _.Ensure(env, oldState, newState, input, result) = result = 0 public class ResetCommand : Command<Counter, CounterState, NoValue, int> { public override string Name => \"Reset\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, CounterState state, NoValue input) { sut.Reset(); var result = sut.Get(); return Task.FromResult(result); } public override Gen<NoValue> Generate(CounterState state) => Gen.Constant(NoValue.Value); public override CounterState Update(CounterState state, NoValue input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoValue input, int result) => result == 0; // Reset always returns 0 } A Get Command (for completeness) Let's add a read-only operation to verify our model stays in sync: F# C# type GetCommand() = inherit Command<Counter, CounterState, unit, int>() override _.Name = \"Get\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = Task.FromResult(counter.Get()) override _.Generate(state) = Gen.constant () override _.Update(state, input, outputVar) = { CurrentCount = outputVar } override _.Ensure(env, oldState, newState, input, result) = // Get should return exactly what's in our model result = oldState.CurrentCount.Resolve(env) public class GetCommand : Command<Counter, CounterState, NoValue, int> { public override string Name => \"Get\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, CounterState state, NoValue input) => Task.FromResult(sut.Get()); public override Gen<NoValue> Generate(CounterState state) => Gen.Constant(NoValue.Value); public override CounterState Update(CounterState state, NoValue input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoValue input, int result) { // Get should return exactly what's in our model return result == oldState.CurrentCount.Resolve(env); } } Creating the Specification Now we tie it all together with a SequentialSpecification: F# C# type CounterSpec() = inherit SequentialSpecification<Counter, CounterState>() // Start each test from 0 override _.SetupCommands = [| ResetCommand() |] // The initial model state override _.InitialState = { CurrentCount = Var.symbolic 0 } // How many commands to generate (1-50) override _.Range = Range.linear 1 50 // All available commands override _.Commands = [| IncrementCommand() DecrementCommand() ResetCommand() GetCommand() |] public class CounterSpec : SequentialSpecification<Counter, CounterState> { // Start each test from 0 public override ICommand<Counter, CounterState>[] SetupCommands => [new ResetCommand()]; // The initial model state public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; // How many commands to generate (1-50) public override Range<int> Range => Hedgehog.Linq.Range.LinearInt32(1, 50); // All available commands public override ICommand<Counter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand(), new ResetCommand(), new GetCommand() ]; } Running the Test Finally, we write our test: F# C# [<Fact>] let ``Counter behaves correctly under random operations``() = let sut = Counter() CounterSpec().ToProperty(sut).Check() [Fact] public void CounterBehavesCorrectlyUnderRandomOperations() { var sut = new Counter(); new CounterSpec().ToProperty(sut).Check(); } That's it! When you run this test, Hedgehog will: Generate random sequences of commands (e.g., \"Increment, Increment, Reset, Decrement, Get\") Execute each sequence against your actual counter Verify each operation produces the expected result If any assertion fails, shrink the sequence to find the minimal failing case Example Test Scenarios Here are some sequences Hedgehog might generate: Simple sequence: 1. Reset → expect 0 2. Increment → expect 1 3. Increment → expect 2 4. Get → expect 2 Edge case: 1. Reset → expect 0 2. Decrement → expect -1 3. Decrement → expect -2 4. Reset → expect 0 5. Get → expect 0 Complex sequence: 1. Increment → expect 1 2. Increment → expect 2 3. Decrement → expect 1 4. Increment → expect 2 5. Reset → expect 0 6. Increment → expect 1 If any command returns an unexpected value, Hedgehog will report exactly which sequence caused the failure and shrink it to the smallest reproduction case. Testing new behaviours Let's assume that now Counter adds a new API method Set: F# C# type Counter() = member _.Set(n: int) = value <- n // the rest of the members public sealed class Counter { public void Set(int n) => _value = n; // the rest of the members } To test it we need to define some SetCommand: F# C# type SetCommand() = inherit Command<Counter, CounterState, int, int>() override _.Name = \"Set\" override _.Precondition(state) = true override _.Execute(counter, _, _, value) = counter.Set(value) let result = counter.Get() Task.FromResult(result) // Generate random integers between -10 and 100 override _.Generate _ = Gen.int32 (Range.linearFrom 0 -10 100) override _.Update(_, _, outputVar) = { CurrentCount = outputVar } override _.Ensure(_, _, _, input, result) = result = input public class SetCommand : Command<Counter, CounterState, int, int> { public override string Name => \"Set\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(Counter sut, Env env, int value) { sut.Set(value); var result = sut.Get(); return Task.FromResult(result); } // Generate random integers between -10 and 100 public override Gen<int> Generate(CounterState state) => Hedgehog.Linq.Gen.Int32(Range.LinearFromInt32(0, -10, 100)); public override CounterState Update(CounterState state, int input, Var<int> outputVar) => state with { CurrentCount = outputVar }; public override bool Ensure(Env env, CounterState oldState, CounterState newState, int input, int result) { return result == input; // Set should set the exact value } } Then add SetCommand() to your Commands array in the specification. Now Hedgehog will use it in generating sequence and will generate sequences like: 1. Set(42) → expect 42 2. Increment → expect 43 3. Set(-5) → expect -5 4. Get → expect -5 What About Bugs? Let's introduce a bug in our counter to see what happens: F# C# member _.Decrement() = if value > 10 then value <- value - 1 else value <- value - 2 // SIMULATE BUG: decrements by 2 when <= 10 public void Decrement() { if (_value > 10) _value--; else _value -= 2; // SIMULATE BUG: decrements by 2 when <= 10 } When you run the test, Hedgehog will find this bug and report something like: *** Failed! Falsifiable (after 8 tests and 1 shrink): You can reproduce this failure with the following Recheck Seed: \"7_13402950062986702852_14277380902303697685_0\" Generated values: { Initial = CounterState { CurrentCount = 0 (symbolic) } Steps = [Reset ; Decrement ] } Counterexamples: Final state: CounterState { CurrentCount = 0 (symbolic) } + Reset Decrement Hedgehog automatically found the minimal reproduction case: decrement once (you can see \"+ Reset\" in the list because Reset is defined as a Setup step and is always executed first). Summary You've learned how to: Define a model state that represents what you expect Create commands for each operation on your SUT Implement the key methods for each command: Name: for debugging Precondition: to control when the command can be generated Generate: to generate inputs Execute: to run the real operation Update: to update the model state Ensure: to verify correctness Create a specification that ties everything together Run the test and let Hedgehog find bugs automatically The beauty of this approach is that Hedgehog explores hundreds or thousands of different sequences automatically, finding edge cases you might never think to test manually."
  },
  "stateful/require.html": {
    "href": "stateful/require.html",
    "title": "Runtime Preconditions with Require | Hedgehog.Stateful",
    "summary": "Runtime Preconditions with Require When you generate a test sequence, Hedgehog creates a plan of actions to execute. But what happens when that plan includes references to values that might not exist when execution time arrives? This is where the Require method becomes essential. The Problem: Symbolic Variables as Input Consider a user registry system where commands can look up previously registered users. Your state might track registered user IDs: F# C# type RegistryState = { RegisteredIds: Var<int> list // List of IDs from previous Register commands } public record RegistryState { public List<Var<int>> RegisteredIds { get; init; } = new(); } When generating a LookupUser command, you need to pick an ID from this list: F# C# type LookupUserCommand() = inherit Command<UserRegistry, RegistryState, Var<int>, UserInfo option>() override _.Precondition(state) = not (List.isEmpty state.RegisteredIds) override _.Generate(state) = Gen.item state.RegisteredIds // Returns a Var<int> from the list public class LookupUserCommand : Command<UserRegistry, RegistryState, Var<int>, UserInfo?> { public override bool Precondition(RegistryState state) => state.RegisteredIds.Count > 0; public override Gen<Var<int>> Generate(RegistryState state) => Gen.Element(state.RegisteredIds); // Returns a Var<int> from the list } Notice: Generate returns a Var<int> - a symbolic reference to an ID that some previous command produced. The Hidden Danger: Shrinking Can Leave Variables Unbound Here's the subtle problem. Imagine Hedgehog generates this sequence (which passes): 1. RegisterUser(\"Alice\") → Var₁ 2. RegisterUser(\"Bob\") → Var₂ 3. RegisterUser(\"Charlie\") → Var₃ 4. LookupUser(Var₂) ← succeeds 5. DeleteUser(Var₃) 6. SomeOtherOperation() ← THIS FAILS! The test fails at step 6. Now Hedgehog tries to shrink the sequence to find the minimal failing case. It might try removing step 2: 1. RegisterUser(\"Alice\") → Var₁ [step 2 removed - \"Bob\" never registered] 3. RegisterUser(\"Charlie\") → Var₃ 4. LookupUser(Var₂) ← CRASH! Var₂ is unbound 5. DeleteUser(Var₃) 6. SomeOtherOperation() What happened? When step 4 was originally generated, the state had [Var₁, Var₂] in RegisteredIds Generate picked Var₂ randomly from that list During shrinking, step 2 (which produced Var₂) was removed Step 4 still has Var₂ as its input, but Var₂ was never bound to a concrete value Without Require, calling Var₂.Resolve(env) will throw an exception This isn't a problem with the test logic—it's a fundamental aspect of how shrinking works. Actions are removed from sequences, but the inputs to remaining actions are fixed when they're generated. The fix: Override Require to check idVar.TryResolve(env, out var _). During shrinking, if the var can't be resolved, Require returns false and the action is skipped (not failed). The shrinking process continues and finds a valid minimal sequence. The Solution: Override Require The Require method is your runtime safety check. Unlike Precondition (which only sees the structural state during generation), Require receives the Env parameter and can resolve symbolic variables to check if they're actually valid. Here's the safe version: F# C# type LookupUserCommand() = inherit Command<UserRegistry, RegistryState, Var<int>, UserInfo option>() override _.Name = \"LookupUser\" // Structural precondition: we need at least one ID in our list override _.Precondition(state) = not (List.isEmpty state.RegisteredIds) // Pick a random ID from the list override _.Generate(state) = Gen.item state.RegisteredIds // Runtime check: can we actually resolve this ID? override _.Require(env, state, idVar) = idVar |> Var.tryResolve env |> Result.isOk override _.Execute(registry, env, state, idVar) = let actualId = idVar.Resolve(env) Task.FromResult(registry.Lookup(actualId)) override _.Ensure(env, oldState, newState, idVar, result) = result.IsSome // Should always find the user public class LookupUserCommand : Command<UserRegistry, RegistryState, Var<int>, UserInfo?> { public override string Name => \"LookupUser\"; // Structural precondition: we need at least one ID in our list public override bool Precondition(RegistryState state) => state.RegisteredIds.Count > 0; // Pick a random ID from the list public override Gen<Var<int>> Generate(RegistryState state) => Gen.Element(state.RegisteredIds); // Runtime check: can we actually resolve this ID? public override bool Require(Env env, RegistryState state, Var<int> idVar) => idVar.TryResolve(env, out var _); // Returns false if not bound yet public override Task<UserInfo?> Execute(UserRegistry sut, Env env, RegistryState state, Var<int> idVar) { var actualId = idVar.Resolve(env); return Task.FromResult(sut.Lookup(actualId)); } public override bool Ensure(Env env, RegistryState oldState, RegistryState newState, Var<int> idVar, UserInfo? result) => result is not null; // Should always find the user } What changes: We override Require to check if idVar can actually be resolved If TryResolve returns false, the command is skipped (not failed!) The test continues with the remaining actions This prevents trying to lookup a user ID that was never actually created. When to Override Require Override Require when: Your Generate returns Var<T> as part of the input - You're selecting from a list of symbolic variables Commands can be skipped - Previous commands might not execute, leaving vars unbound You need runtime value checks - Validate concrete values that weren't available during generation You can skip Require when: Generate returns concrete values only - No symbolic variables in the input Simple preconditions - Structural checks that Precondition already handles All commands always execute - No risk of skipped actions (rare in practice) Best Practices 1. Use TryResolve for Safety Don't use Resolve directly in Require - it throws if the variable isn't bound. In F#, use the idiomatic Var.tryResolve which returns a Result: F# C# override _.Require(env, state, input) = input.SomeVarField |> Var.tryResolve env |> Result.isOk In C#, use TryResolve with an out parameter: public override bool Require(Env env, MyState state, MyInput input) => input.SomeVarField.TryResolve(env, out var _); 2. Check the Symbolic Inputs You Use If your command's input contains Var<T> fields that come from previous command outputs, and your Execute method will resolve them, you should check those in Require: F# C# type TransferInput = { FromAccount: Var<AccountId> // From a previous CreateAccount command ToAccount: Var<AccountId> // From a previous CreateAccount command Amount: decimal } override _.Require(env, state, input) = // Check both vars since Execute will resolve both (input.FromAccount |> Var.tryResolve env |> Result.isOk) && (input.ToAccount |> Var.tryResolve env |> Result.isOk) public record TransferInput { // From previous CreateAccount commands public required Var<AccountId> FromAccount { get; init; } public required Var<AccountId> ToAccount { get; init; } public decimal Amount { get; init; } } public override bool Require(Env env, BankState state, TransferInput input) => // Check both vars since Execute will resolve both input.FromAccount.TryResolve(env, out var _) && input.ToAccount.TryResolve(env, out var _); Important distinctions: Vars from command inputs (produced by Generate picking from state lists): These can become unbound during shrinking and need to be checked in Require Vars in the state (created with Var.symbolic in InitialState): These always have default values and are always resolvable, so they don't need Require checks Only check what you use: Only check the Var<T> fields that your Execute method actually resolves. If your command doesn't use a particular var from the input, you don't need to check it in Require Require vs Precondition It's important to understand the difference between these two methods: Aspect Precondition Require When called During generation & execution Only during execution Has Env? ❌ No - cannot resolve vars ✅ Yes - can resolve vars Purpose Structural check (\"do we have IDs?\") Runtime check (\"can we resolve this ID?\") Return false means Don't generate this command Skip this command (continue test) Check frequency Every candidate command Only generated commands In practice: Use Precondition for structural state checks, and Require for validating symbolic variable inputs. Summary The Rule: If your Generate method returns a Var<T> (or contains one as a part of a generated input), always override Require to check if that variable can be resolved. Why: Commands can be skipped during execution, leaving symbolic variables unbound. Without Require, you'll crash trying to resolve non-existent values. How: Use TryResolve to safely check if a variable is bound before attempting to use it in Execute. This pattern keeps your stateful tests robust and prevents mysterious failures from unresolved symbolic variables."
  },
  "stateful/specifications.html": {
    "href": "stateful/specifications.html",
    "title": "Specifications | Hedgehog.Stateful",
    "summary": "Specifications Once you've defined your commands, you need a specification that ties everything together. A specification declares: The initial state of your model Which commands are available How many actions to generate Whether to test sequentially or in parallel Hedgehog provides two types of specifications: SequentialSpecification: Tests sequences of operations running one after another ParallelSpecification: Tests concurrent operations to verify linearizability Sequential Specifications Sequential specifications test your system by generating and executing sequences of commands one at a time. This is the most common type of stateful test. Basic Structure F# C# type CounterSpec() = inherit SequentialSpecification<Counter, CounterState>() // The starting state of your model override _.InitialState = { CurrentCount = Var.symbolic 0 } // How many actions to generate (1 to 10) override _.Range = Range.linear 1 10 // Available commands override _.Commands = [| IncrementCommand() DecrementCommand() ResetCommand() |] public class CounterSpec : SequentialSpecification<Counter, CounterState> { // The starting state of your model public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; // How many actions to generate (1 to 10) public override Range<int> Range => Range.Linear(1, 10); // Available commands public override ICommand<Counter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand(), new ResetCommand() ]; } Running the Test Convert the specification to a property and check it as a regular property: F# C# [<Fact>] let ``Counter behaves correctly``() = // obtain sut somehow let sut = Counter() CounterSpec().ToProperty(sut).Check() [Fact] public void Counter_BehavesCorrectly() { // obtain sut somehow var sut = new Counter(); new CounterSpec().ToProperty(sut).Check(); } Setup and Cleanup Sequential specifications support setup and cleanup commands that run before and after each test sequence: F# C# type CounterSpec() = inherit SequentialSpecification<Counter, CounterState>() override _.InitialState = { CurrentCount = Var.symbolic 0 } override _.Range = Range.linear 1 10 // Setup runs BEFORE the test sequence override _.SetupCommands = [| InitializeCommand() // e.g., set counter to a random value |] // Main test commands override _.Commands = [| IncrementCommand() DecrementCommand() |] // Cleanup runs AFTER the test sequence override _.CleanupCommands = [| ResetCommand() // e.g., reset counter to 0 |] public class CounterSpec : SequentialSpecification<Counter, CounterState> { public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; public override Range<int> Range => Range.Linear(1, 10); // Setup runs BEFORE the test sequence public override ICommand<Counter, CounterState>[] SetupCommands => [ new InitializeCommand() // e.g., set counter to a random value ]; // Main test commands public override ICommand<Counter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand() ]; // Cleanup runs AFTER the test sequence public override ICommand<Counter, CounterState>[] CleanupCommands => [ new ResetCommand() // e.g., reset counter to 0 ]; } Key points about setup and cleanup: Setup commands execute in order before test commands. Cleanup commands execute in order after test commands. Cleanup runs even if the test fails Both setup and cleanup commands can have their parameters shrink, but they cannot be removed from the sequence during shrinking. Parallel Specifications Parallel specifications test whether your system is linearizable—meaning concurrent operations behave as if they executed in some sequential order. What is Linearizability? When operations run concurrently, they can interfere with each other. A linearizable system guarantees that despite this interference, the results match what could have happened if the operations ran sequentially. For example, if two threads both increment a counter, linearizability ensures the counter increases by 2—not 1 (which would indicate a lost update). How Parallel Testing Works Parallel testing has three phases: Sequential Prefix: Run some operations sequentially to set up initial state Parallel Branches: Run two sequences of operations in parallel on the same system Linearizability Check: Verify the results match some interleaving of the operations Basic Structure F# C# type ParallelCounterSpec() = inherit ParallelSpecification<ThreadSafeCounter, CounterState>() // Starting state override _.InitialState = { CurrentCount = Var.symbolic 0 } // Length of sequential prefix (0-3 operations) override _.PrefixRange = Range.linear 0 3 // Length of each parallel branch (1-5 operations each) override _.BranchRange = Range.linear 1 5 // Commands that can run in parallel override _.Commands = [| IncrementCommand() DecrementCommand() GetCommand() |] public class ParallelCounterSpec : ParallelSpecification<ThreadSafeCounter, CounterState> { // Starting state public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; // Length of sequential prefix (0-3 operations) public override Range<int> PrefixRange => Range.Linear(0, 3); // Length of each parallel branch (1-5 operations each) public override Range<int> BranchRange => Range.Linear(1, 5); // Commands that can run in parallel public override ICommand<ThreadSafeCounter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand(), new GetCommand() ]; } Running Parallel Tests F# C# [<Fact>] let ``Counter is thread-safe``() = let sut = ThreadSafeCounter() ParallelCounterSpec().ToProperty(sut).Check() [Fact] public void Counter_IsThreadSafe() { var sut = new ThreadSafeCounter(); new ParallelCounterSpec().ToProperty(sut).Check(); } Important: Sharing the SUT The same SUT instance is intentionally shared between parallel branches. This is not a bug - it's the whole point! We want operations to interfere with each other because we're testing whether the system handles concurrent access correctly. If the system is properly thread-safe, all results will be linearizable. If it has concurrency bugs, some test runs will produce results that can't be explained by any sequential ordering. Writing Commands for Parallel Testing When writing commands for parallel testing, remember: Preconditions and Require still check the model state Ensure should verify weak postconditions—linearizability checking handles the strong guarantees Return values matter—the framework uses them to verify linearizability Example of a weak postcondition in parallel context: F# C# type IncrementCommand() = inherit Command<ThreadSafeCounter, CounterState, unit, int>() override _.Name = \"Increment\" override _.Precondition(state) = true override _.Execute(counter, env, state, input) = Task.FromResult(counter.Increment()) override _.Generate(state) = Gen.constant () override _.Update(state, input, outputVar) = { CurrentCount = outputVar } // Weak postcondition: we can't assert the exact value // Linearizability checking verifies the sequence is valid override _.Ensure(env, oldState, newState, input, result) = result > 0 // After increment, should be positive public class IncrementCommand : Command<ThreadSafeCounter, CounterState, NoValue, int> { public override string Name => \"Increment\"; public override bool Precondition(CounterState state) => true; public override Task<int> Execute(ThreadSafeCounter sut, Env env, CounterState state, NoValue input) => Task.FromResult(sut.Increment()); public override Gen<NoValue> Generate(CounterState state) => Gen.Constant(NoValue.Value); public override CounterState Update(CounterState state, NoValue input, Var<int> outputVar) => state with { CurrentCount = outputVar }; // Weak postcondition: we can't assert the exact value // Linearizability checking verifies the sequence is valid public override bool Ensure(Env env, CounterState oldState, CounterState newState, NoValue input, int result) => result > 0; // After increment, should be positive } Setup and Cleanup in Parallel Tests Parallel specifications also support setup and cleanup: F# C# type ParallelCounterSpec() = inherit ParallelSpecification<ThreadSafeCounter, CounterState>() override _.InitialState = { CurrentCount = Var.symbolic 0 } override _.PrefixRange = Range.linear 0 3 override _.BranchRange = Range.linear 1 5 // Setup runs BEFORE prefix and parallel branches override _.SetupCommands = [| InitializeCommand() |] override _.Commands = [| IncrementCommand() DecrementCommand() |] // Cleanup runs AFTER parallel branches complete override _.CleanupCommands = [| ResetCommand() |] public class ParallelCounterSpec : ParallelSpecification<ThreadSafeCounter, CounterState> { public override CounterState InitialState => new() { CurrentCount = Var.Symbolic(0) }; public override Range<int> PrefixRange => Range.Linear(0, 3); public override Range<int> BranchRange => Range.Linear(1, 5); // Setup runs BEFORE prefix and parallel branches public override ICommand<ThreadSafeCounter, CounterState>[] SetupCommands => [ new InitializeCommand() ]; public override ICommand<ThreadSafeCounter, CounterState>[] Commands => [ new IncrementCommand(), new DecrementCommand() ]; // Cleanup runs AFTER parallel branches complete public override ICommand<ThreadSafeCounter, CounterState>[] CleanupCommands => [ new ResetCommand() ]; } Note: Cleanup is generated using the state after the prefix (before parallel execution), since the parallel branches can't be used to predict a single final state. But it is executed at the end of the whole sequence. Using Fresh SUTs Instead of creating the SUT yourself and passing it to the specification, you can provide a factory function that creates a fresh SUT for each test run: F# C# [<Fact>] let ``Counter test with fresh SUT``() = // Factory creates a new Counter for each test let createSut() = Counter() CounterSpec().ToPropertyWith(createSut).Check() [Fact] public void Counter_TestWithFreshSUT() { // Factory creates a new Counter for each test Func<Counter> createSut = () => new Counter(); new CounterSpec().ToPropertyWith(createSut).Check(); } This approach ensures test isolation—each test run gets a completely fresh system. Summary Sequential Specifications: Test operations running one after another Use SequentialSpecification<TSystem, TState> Define InitialState, Range, and Commands Optionally add SetupCommands and CleanupCommands Parallel Specifications: Test concurrent operations for linearizability Use ParallelSpecification<TSystem, TState> Define InitialState, PrefixRange, BranchRange, and Commands The same SUT is intentionally shared between parallel branches Linearizability checking verifies results match some sequential interleaving Optionally add SetupCommands and CleanupCommands Both specifications provide: Automatic shrinking of test sequences Setup/cleanup command support Clear failure reporting Integration with property-based testing frameworks"
  }
}